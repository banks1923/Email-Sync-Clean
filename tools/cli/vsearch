#!/usr/bin/env python3

"""

AI-Powered Hybrid Vector Search CLI - Fixed Version
Uses new clean services architecture
Usage: scripts/vsearch [command] [options]
"""

import argparse
import json
import sys
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import new clean services
try:
    from shared.utils.error_handler import ErrorHandler

    SERVICES_AVAILABLE = True
except ImportError:
    SERVICES_AVAILABLE = False
    print("âš ï¸  Clean services not available, using fallback")


def search_command(query: str, limit: int = 5, hybrid: bool = True) -> bool:
    """AI-Powered Unified Search using clean services"""
    print(f"ðŸ¤– AI-Powered Search for: '{query}'")

    if hybrid and SERVICES_AVAILABLE:
        # Try semantic search with new SearchService
        print("ðŸ” Running semantic search...")
        try:
            # Only call get_search_service if SERVICES_AVAILABLE is True
            search = get_search_service()
            results = search.search(query, limit=limit)

            if results:
                print(f"âœ… Found {len(results)} semantic matches")
                display_results(results, "ðŸ§  Semantic Search")
                return True
            else:
                print("âš ï¸  No semantic results, trying keyword search...")
        except Exception as e:
            print(f"âš ï¸  Semantic search unavailable ({e}), falling back to keyword search")

    # Fallback to keyword search using SimpleDB
    print("ðŸ” Running keyword search...")
    try:
        db = SimpleDB()
        results = db.search_content(query, limit=limit)

        if results:
            print(f"âœ… Found {len(results)} keyword matches")
            display_keyword_results(results, "ðŸ”¤ Keyword Search")
            return True
        else:
            print("âŒ No results found")
            return False
    except Exception as e:
        print(f"âŒ Search failed: {e}")
        return False


def display_results(results, search_type):
    """Display semantic search results"""
    print(f"\n=== {search_type} Results ===")

    for i, result in enumerate(results, 1):
        score = result.get("score", 1.0)
        metadata = result.get("metadata", {})
        content = result.get("content", {})

        # Determine content type from metadata
        content_type = metadata.get("type", "unknown")
        type_icons = {"email": "ðŸ“§", "pdf": "ðŸ“„", "transcript": "ðŸŽ™ï¸"}
        icon = type_icons.get(content_type, "ðŸ“„")

        print(f"\n--- {icon} Result {i} (Score: {score:.3f}) ---")

        # Display based on what's available
        if isinstance(content, dict):
            print(f"Title: {content.get('title', 'No title')}")
            if content.get("sender"):
                print(f"From: {content['sender']}")
            if content.get("date"):
                print(f"Date: {content['date']}")

            # Show snippet
            body = content.get("content", content.get("body", ""))
            if body:
                snippet = body[:200].replace("\n", " ")
                print(f"Content: {snippet}...")
        else:
            # Fallback display
            print(f"Content: {str(content)[:200]}...")


def display_keyword_results(results, search_type):
    """Display keyword search results from SimpleDB"""
    print(f"\n=== {search_type} Results ===")

    for i, result in enumerate(results, 1):
        # SimpleDB returns dict with id, type, title, content, metadata, etc.
        content_type = result.get("type", "unknown")
        type_icons = {"email": "ðŸ“§", "pdf": "ðŸ“„", "transcript": "ðŸŽ™ï¸"}
        icon = type_icons.get(content_type, "ðŸ“„")

        print(f"\n--- {icon} Result {i} ---")
        print(f"Title: {result.get('title', 'No title')}")
        print(f"Type: {content_type}")

        # Parse metadata if it's a string
        metadata = result.get("metadata", {})
        if isinstance(metadata, str):
            try:
                metadata = json.loads(metadata)
            except:
                metadata = {}

        # Show metadata based on type
        if content_type == "email" and metadata:
            print(f"From: {metadata.get('sender', 'Unknown')}")
            print(f"Date: {metadata.get('date', 'Unknown')}")

        # Show content snippet
        content = result.get("content", "")
        if content:
            snippet = content[:200].replace("\n", " ")
            print(f"Content: {snippet}...")


def info_command():
    """Display system information using new services"""
    print("ðŸ“Š System Information")
    print("=" * 50)

    # Database stats
    try:
        db = SimpleDB()
        stats = db.get_content_stats()
        print("\nðŸ“ Database Statistics:")
        print(f"  Total emails: {stats.get('total_emails', 0)}")
        print(f"  Total PDFs: {stats.get('total_pdfs', 0)}")
        print(f"  Total transcripts: {stats.get('total_transcripts', 0)}")
        print(f"  Total content: {stats.get('total_content', 0)}")
    except Exception as e:
        print(f"  âš ï¸  Database unavailable: {e}")

    # Vector service status
    if SERVICES_AVAILABLE:
        try:
            from vector_store import get_vector_store

            store = get_vector_store()
            print("\nðŸ§  Vector Service:")
            print("  Status: âœ… Connected")
            print(f"  Collection: {store.collection}")
            print(f"  Dimensions: {store.dimensions}")
        except Exception as e:
            print("\nðŸ§  Vector Service:")
            print(f"  Status: âŒ Not available ({e})")

    # Embeddings status
    if SERVICES_AVAILABLE:
        try:
            from embeddings import get_embedding_service

            emb = get_embedding_service()
            print("\nðŸ¤– Embedding Service:")
            print(f"  Model: {emb.model_name}")
            print(f"  Dimensions: {emb.dimensions}")
            print(f"  Device: {emb.device}")
        except Exception as e:
            print("\nðŸ¤– Embedding Service:")
            print(f"  Status: âš ï¸  Not configured ({e})")

    print("\nâœ… System check complete")


def upload_command(file_path):
    """Upload and process a document"""
    from pathlib import Path

    file_path = Path(file_path)
    if not file_path.exists():
        print(f"âŒ File not found: {file_path}")
        return False

    print(f"ðŸ“¤ Uploading: {file_path.name}")

    try:
        # Handle based on file type
        if file_path.suffix.lower() == ".pdf":
            from pdf.main import PDFService

            pdf_service = PDFService()
            result = pdf_service.upload_single_pdf(str(file_path))
            if result.get("success"):
                print("âœ… PDF processed successfully")
                print(f"  Document ID: {result.get('document_id')}")
                print(f"  Chunks created: {result.get('chunks_created', 0)}")
            else:
                print(f"âŒ Processing failed: {result.get('error')}")
        else:
            print(f"âŒ Unsupported file type: {file_path.suffix}")
            return False

    except Exception as e:
        print(f"âŒ Upload failed: {e}")
        return False

    return True


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="AI-Powered Vector Search CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Search command
    search_parser = subparsers.add_parser("search", help="Search content")
    search_parser.add_argument("query", help="Search query")
    search_parser.add_argument("-n", "--limit", type=int, default=5, help="Number of results")
    search_parser.add_argument(
        "--keyword-only", action="store_true", help="Use keyword search only"
    )

    # Info command
    subparsers.add_parser("info", help="Display system information")

    # Upload command
    upload_parser = subparsers.add_parser("upload", help="Upload and process a document")
    upload_parser.add_argument("file", help="Path to file to upload")

    args = parser.parse_args()

    # Default to search if no command but arguments provided
    if not args.command and len(sys.argv) > 1:
        # Treat first argument as search query
        query = " ".join(sys.argv[1:])
        search_command(query)
    elif args.command == "search":
        search_command(args.query, args.limit, hybrid=not args.keyword_only)
    elif args.command == "info":
        info_command()
    elif args.command == "upload":
        upload_command(args.file)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
